import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import Ridge, LinearRegression
from sklearn.multioutput import MultiOutputRegressor
from sklearn.neural_network import MLPRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import warnings
warnings.filterwarnings('ignore')

print("MODELO H√çBRIDO COMPLETO - MATRIZ EL√âTRICA BRASILEIRA")
print("="*65)

# === 1. CARREGAR DADOS ===
df_variaveis = pd.read_csv("variaveis_externas_template.csv")
df_matriz = pd.read_csv("base_matriz_eletrica_normalizada.csv")

# === 2. CALCULAR TEND√äNCIAS HIST√ìRICAS (2014-2023) ===
def calcular_tendencias_historicas(df_matriz, ano_inicio=2014):
    """
    Calcula tend√™ncias robustas a partir de 2014 (p√≥s-crise h√≠drica)
    """
    df_periodo = df_matriz[df_matriz['ANO'] >= ano_inicio].copy()
    
    print(f"TEND√äNCIAS HIST√ìRICAS ({ano_inicio}-2023) - {len(df_periodo)} anos")
    print("-" * 50)
    
    tendencias = {}
    fontes = [col for col in df_matriz.columns if col != 'ANO']
    
    for fonte in fontes:
        valores = df_periodo[fonte].values
        anos = df_periodo['ANO'].values
        
        if len(valores) >= 3:
            # Regress√£o linear para tend√™ncia
            coef = np.polyfit(anos, valores, 1)[0]
            intercept = np.polyfit(anos, valores, 1)[1]
            
            # R¬≤ da tend√™ncia
            y_pred = coef * anos + intercept
            ss_res = np.sum((valores - y_pred) ** 2)
            ss_tot = np.sum((valores - np.mean(valores)) ** 2)
            r2 = 1 - (ss_res / ss_tot) if ss_tot > 0 else 0
            
            tendencias[fonte] = {
                'coef': coef,
                'intercept': intercept,
                'r2': r2,
                'valor_2023': valores[-1],
                'n_anos': len(valores)
            }
            
            # Mostrar tend√™ncias significativas
            if abs(coef) > 0.1 or r2 > 0.5:
                direcao = "/" if coef > 0 else "\"
                confianca = "üü¢" if r2 > 0.7 else "üü°" if r2 > 0.4 else "üî¥"
                print(f"{direcao} {fonte}: {coef:+.3f}%/ano (R¬≤={r2:.2f}) {confianca}")
        else:
            # Fallback para fontes com poucos dados
            ultimo_valor = valores[-1] if len(valores) > 0 else 0
            tendencias[fonte] = {
                'coef': 0, 'intercept': ultimo_valor, 'r2': 0,
                'valor_2023': ultimo_valor, 'n_anos': len(valores)
            }
    
    return tendencias

# === 3. CRIAR VARI√ÅVEIS DE POL√çTICA REAL√çSTICAS ===
def criar_variaveis_realistas(df_variaveis):
    """
    Cria transi√ß√µes em S-curve baseadas na realidade brasileira
    """
    df_real = df_variaveis.copy()
    
    print(f"\nCRIANDO TRANSI√á√ïES REAL√çSTICAS")
    print("-" * 40)
    
    for i, row in df_real.iterrows():
        ano = row['ANO']
        
        if ano <= 2024:
            continue  # Manter dados hist√≥ricos
            
        # META_SOLAR: S-curve com acelera√ß√£o p√≥s-2030
        if ano <= 2030:
            # Fase 1: Crescimento lento (decolagem)
            df_real.at[i, 'META_SOLAR'] = 0.1 + (ano - 2025) * 0.08
        elif ano <= 2040:
            # Fase 2: Crescimento acelerado (metas governamentais)
            base = 0.5
            progresso = (ano - 2030) / 10
            df_real.at[i, 'META_SOLAR'] = base + progresso * 0.4
        else:
            # Fase 3: Estabiliza√ß√£o
            df_real.at[i, 'META_SOLAR'] = 0.9
        
        # NOVAS_TECNOLOGIAS: Crescimento gradual
        if ano <= 2035:
            df_real.at[i, 'NOVAS_TECNOLOGIAS'] = min(0.8, (ano - 2025) * 0.06)
        else:
            df_real.at[i, 'NOVAS_TECNOLOGIAS'] = 0.8
        
        # POLITICA_TERMICA_GAS: Ciclos pol√≠ticos real√≠sticos
        ciclo_base = 0.3 + 0.4 * np.sin((ano - 2025) * 0.3)
        ruido = np.random.RandomState(ano).normal(0, 0.1)  # Ru√≠do determin√≠stico
        df_real.at[i, 'POLITICA_TERMICA_GAS'] = max(0, min(1, ciclo_base + ruido))
    
    print("Transi√ß√µes S-curve aplicadas (lento ‚Üí r√°pido ‚Üí estabiliza√ß√£o)")
    return df_real

# === 4. FEATURE ENGINEERING ===
def criar_features_avancadas(df_variaveis):
    """
    Cria features que capturam intera√ß√µes entre pol√≠ticas
    """
    df_eng = df_variaveis.copy()
    
    print(f"FEATURE ENGINEERING")
    print("-" * 25)
    
    # Sinergias entre pol√≠ticas
    df_eng['SOLAR_EOLICA_SINERGIA'] = df_eng['META_SOLAR'] * df_eng['META_EOLICA']
    df_eng['RENOVAVEIS_TOTAL'] = (df_eng['META_SOLAR'] + df_eng['META_EOLICA'] + 
                                  df_eng['META_HIDRICA'] + df_eng['META_CANA']) / 4
    
    # Competi√ß√£o t√©rmica vs renov√°vel
    df_eng['COMPETICAO_TERMICA'] = df_eng['POLITICA_TERMICA_GAS'] * (1 - df_eng['RENOVAVEIS_TOTAL'])
    
    # Tend√™ncia temporal normalizada
    df_eng['TENDENCIA_ANOS'] = (df_eng['ANO'] - df_eng['ANO'].min()) / (df_eng['ANO'].max() - df_eng['ANO'].min())
    
    # Acelera√ß√£o p√≥s-2030 (n√£o-linear)
    df_eng['ACELERACAO_POS_2030'] = np.where(df_eng['ANO'] >= 2030, 
                                            ((df_eng['ANO'] - 2030) / 10) ** 2, 0)
    
    return df_eng

# === 5. PROJE√á√ÉO H√çBRIDA APRIMORADA ===
def projecao_hibrida_avancada(df_futuro, tendencias, nome_cenario="BASE", intensidade=1.0):
    """
    Combina tend√™ncias hist√≥ricas + ajustes de pol√≠tica + restri√ß√µes real√≠sticas
    """
    resultados = []
    
    for _, row in df_futuro.iterrows():
        ano = row['ANO']
        anos_futuro = ano - 2023
        
        projecao_ano = {'ANO': ano}
        
        for fonte, info_tend in tendencias.items():
            # 1. Proje√ß√£o base (tend√™ncia hist√≥rica)
            valor_base = info_tend['valor_2023'] + info_tend['coef'] * anos_futuro
            
            # 2. Ajustes espec√≠ficos por fonte e cen√°rio
            if fonte == 'SOLAR':
                meta_solar = row.get('META_SOLAR', 0)
                novas_tech = row.get('NOVAS_TECNOLOGIAS', 0)
                
                # Multiplicador de pol√≠tica
                multiplicador = 1 + (meta_solar * novas_tech * intensidade * 2)
                
                # Crescimento por cen√°rio
                if nome_cenario == "RENOVAVEIS_ACELERADAS":
                    valor_solar = info_tend['valor_2023'] * (1.35 ** (anos_futuro * multiplicador * 0.15))
                    valor_solar = min(valor_solar, 25)  # Limite agressivo
                elif nome_cenario == "FOSSIL_RESISTENTE":
                    valor_solar = info_tend['valor_2023'] * (1.15 ** (anos_futuro * multiplicador * 0.08))
                    valor_solar = min(valor_solar, 8)   # Limite conservador
                else:  # BASE e outros
                    valor_solar = info_tend['valor_2023'] * (1.25 ** (anos_futuro * multiplicador * 0.12))
                    valor_solar = min(valor_solar, 18)
                
                valor_final = valor_solar
                
            elif fonte == 'EOLICA':
                meta_eolica = row.get('META_EOLICA', 0)
                
                if nome_cenario == "FOSSIL_RESISTENTE":
                    valor_final = valor_base * (0.8 + 0.2 * meta_eolica * intensidade)
                else:
                    multiplicador = 1.1 if nome_cenario == "RENOVAVEIS_ACELERADAS" else 1.0
                    valor_final = valor_base * (1 + 0.3 * meta_eolica * intensidade * multiplicador)
                
                valor_final = min(valor_final, 35)
                
            elif fonte == 'HIDRAULICA':
                # Press√£o de outras renov√°veis
                pressao = (row.get('META_SOLAR', 0) + row.get('META_EOLICA', 0) + 
                          row.get('NOVAS_TECNOLOGIAS', 0)) / 3
                
                if nome_cenario == "FOSSIL_RESISTENTE":
                    declinio = pressao * 0.3 * intensidade * anos_futuro
                    valor_final = valor_base - declinio
                    valor_final = max(valor_final, 50)  # M√≠nimo alto
                elif nome_cenario == "RENOVAVEIS_ACELERADAS":
                    declinio = pressao * 0.8 * intensidade * anos_futuro
                    valor_final = valor_base - declinio
                    valor_final = max(valor_final, 30)  # Decl√≠nio acentuado
                else:  # BASE
                    declinio = pressao * 0.5 * intensidade * anos_futuro
                    valor_final = valor_base - declinio
                    valor_final = max(valor_final, 35)
                    
            elif fonte == 'GAS_NATURAL':
                politica_gas = row.get('POLITICA_TERMICA_GAS', 0)
                
                if nome_cenario == "FOSSIL_RESISTENTE":
                    valor_final = valor_base * (1 + politica_gas * 1.2 * intensidade)
                    valor_final = min(valor_final, 18)
                else:
                    valor_final = valor_base * (1 + politica_gas * 0.4 * intensidade)
                    valor_final = min(valor_final, 12)
                    
            elif fonte == 'NUCLEAR':
                meta_nuclear = row.get('META_NUCLEAR', 0)
                
                if nome_cenario == "NUCLEAR_PLUS":
                    valor_final = valor_base * (1 + meta_nuclear * 1.0 * intensidade)
                    valor_final = min(valor_final, 10)
                elif nome_cenario != "FOSSIL_RESISTENTE":
                    valor_final = valor_base * (1 + meta_nuclear * 0.3 * intensidade)
                    valor_final = min(valor_final, 6)
                else:
                    valor_final = valor_base
                    
            else:
                # Outras fontes: tend√™ncia + pequenos ajustes
                valor_final = valor_base
            
            projecao_ano[fonte] = max(0, valor_final)
        
        resultados.append(projecao_ano)
    
    return pd.DataFrame(resultados)

# === 6. CRIAR CEN√ÅRIOS EXTREMOS ===
def criar_cenarios_diferenciados(df_futuro_base):
    """
    Cen√°rios com diferen√ßas marcantes para an√°lise de sensibilidade
    """
    print(f"CRIANDO CEN√ÅRIOS DIFERENCIADOS")
    print("-" * 35)
    
    cenarios = {}
    
    # BASE - transi√ß√£o moderada
    cenarios["BASE"] = df_futuro_base.copy()
    
    # RENOVAVEIS_ACELERADAS - transi√ß√£o energ√©tica agressiva
    cenarios["RENOVAVEIS_ACELERADAS"] = df_futuro_base.copy()
    mask_renv = cenarios["RENOVAVEIS_ACELERADAS"]["ANO"] >= 2025
    cenarios["RENOVAVEIS_ACELERADAS"].loc[mask_renv, "META_SOLAR"] *= 2.0
    cenarios["RENOVAVEIS_ACELERADAS"].loc[mask_renv, "META_EOLICA"] *= 1.5
    cenarios["RENOVAVEIS_ACELERADAS"].loc[mask_renv, "NOVAS_TECNOLOGIAS"] *= 1.8
    cenarios["RENOVAVEIS_ACELERADAS"].loc[mask_renv, "POLITICA_TERMICA_GAS"] *= 0.3
    
    # FOSSIL_RESISTENTE - resist√™ncia √† mudan√ßa
    cenarios["FOSSIL_RESISTENTE"] = df_futuro_base.copy()
    mask_foss = cenarios["FOSSIL_RESISTENTE"]["ANO"] >= 2025
    cenarios["FOSSIL_RESISTENTE"].loc[mask_foss, "META_SOLAR"] *= 0.3
    cenarios["FOSSIL_RESISTENTE"].loc[mask_foss, "META_EOLICA"] *= 0.7
    cenarios["FOSSIL_RESISTENTE"].loc[mask_foss, "NOVAS_TECNOLOGIAS"] *= 0.4
    cenarios["FOSSIL_RESISTENTE"].loc[mask_foss, "POLITICA_TERMICA_GAS"] *= 2.0
    cenarios["FOSSIL_RESISTENTE"]["POLITICA_TERMICA_GAS"] = np.minimum(
        cenarios["FOSSIL_RESISTENTE"]["POLITICA_TERMICA_GAS"], 1.0
    )
    
    # NUCLEAR_PLUS - aposta na energia nuclear
    cenarios["NUCLEAR_PLUS"] = df_futuro_base.copy()
    mask_nuc = cenarios["NUCLEAR_PLUS"]["ANO"] >= 2030
    cenarios["NUCLEAR_PLUS"].loc[mask_nuc, "META_NUCLEAR"] = 1.0
    cenarios["NUCLEAR_PLUS"].loc[mask_nuc, "META_SOLAR"] *= 1.2
    
    # Recriar features para todos os cen√°rios
    for nome in cenarios:
        cenarios[nome] = criar_features_avancadas(cenarios[nome])
    
    print(f" {len(cenarios)} cen√°rios criados (BASE, RENOVAVEIS_ACELERADAS, FOSSIL_RESISTENTE, NUCLEAR_PLUS)")
    return cenarios

# === 7. EXECUTAR PIPELINE COMPLETO ===

# Calcular tend√™ncias
tendencias = calcular_tendencias_historicas(df_matriz)

# Preparar dados
df_variaveis_real = criar_variaveis_realistas(df_variaveis)
df_variaveis_eng = criar_features_avancadas(df_variaveis_real)
df_futuro_base = df_variaveis_eng[df_variaveis_eng["ANO"] > 2023].copy()

# Criar cen√°rios
cenarios = criar_cenarios_diferenciados(df_futuro_base)

# Intensidades de pol√≠tica por cen√°rio
intensidades = {
    "BASE": 1.0,
    "RENOVAVEIS_ACELERADAS": 1.5,
    "FOSSIL_RESISTENTE": 0.7,
    "NUCLEAR_PLUS": 1.2
}

# === 8. PROJE√á√ïES FINAIS ===
print(f"EXECUTANDO PROJE√á√ïES H√çBRIDAS")
print("=" * 40)

resultados_finais = {}

for nome_cenario, df_cenario in cenarios.items():
    print(f"\n--- {nome_cenario} ---")
    
    intensidade = intensidades.get(nome_cenario, 1.0)
    
    # Fazer proje√ß√£o
    df_resultado = projecao_hibrida_avancada(
        df_cenario, tendencias, nome_cenario, intensidade
    )
    
    # Normalizar para somar 100%
    fontes_cols = [col for col in df_resultado.columns if col != 'ANO']
    for idx in df_resultado.index:
        soma = df_resultado.loc[idx, fontes_cols].sum()
        if soma > 0:
            df_resultado.loc[idx, fontes_cols] = (df_resultado.loc[idx, fontes_cols] / soma * 100)
    
    resultados_finais[nome_cenario] = df_resultado
    
    # Mostrar resultados chave
    for ano_ref in [2030, 2040, 2050]:
        if ano_ref in df_resultado['ANO'].values:
            linha = df_resultado[df_resultado['ANO'] == ano_ref]
            if not linha.empty:
                principais = linha[fontes_cols].iloc[0].nlargest(4)
                print(f"\n{ano_ref}:")
                for fonte, valor in principais.items():
                    print(f"  {fonte}: {valor:.1f}%")
                
                # M√©tricas especiais
                solar = linha['SOLAR'].iloc[0] if 'SOLAR' in linha.columns else 0
                hidro = linha['HIDRAULICA'].iloc[0] if 'HIDRAULICA' in linha.columns else 0
                eolica = linha['EOLICA'].iloc[0] if 'EOLICA' in linha.columns else 0
                
                print(f"  Solar: {solar:.1f}% | Hidro: {hidro:.1f}% | E√≥lica: {eolica:.1f}%")

# === 9. AN√ÅLISE COMPARATIVA ===
print(f"\nAN√ÅLISE COMPARATIVA DOS CEN√ÅRIOS EM 2050")
print("=" * 55)

dados_2050 = {}
for nome, df_resultado in resultados_finais.items():
    linha_2050 = df_resultado[df_resultado['ANO'] == 2050]
    if not linha_2050.empty:
        dados_2050[nome] = linha_2050[fontes_cols].iloc[0]

if dados_2050:
    df_comp_2050 = pd.DataFrame(dados_2050).round(1)
    
    # Principais fontes
    fontes_principais = ['HIDRAULICA', 'SOLAR', 'EOLICA', 'GAS_NATURAL', 'NUCLEAR', 'BAGA√áO_CANA']
    fontes_disponiveis = [f for f in fontes_principais if f in df_comp_2050.index]
    
    print("\nTabela Comparativa (%):")
    print(df_comp_2050.loc[fontes_disponiveis].to_string())
    
    # √çndice de diversifica√ß√£o (Herfindahl)
    print(f"\nDIVERSIFICA√á√ÉO DA MATRIZ (2050):")
    for cenario in df_comp_2050.columns:
        valores = df_comp_2050[cenario].values
        hhi = sum((v/100)**2 for v in valores if v > 0)
        nivel = 'Baixa' if hhi < 0.3 else 'M√©dia' if hhi < 0.4 else 'Alta'
        print(f"   {cenario}: HHI = {hhi:.3f} ({nivel} concentra√ß√£o)")

# === 10. VISUALIZA√á√ïES FINAIS ===
print(f"\n... GERANDO VISUALIZA√á√ïES...")

fig, axes = plt.subplots(2, 2, figsize=(16, 12))
axes = axes.ravel()

fontes_viz = ['HIDRAULICA', 'SOLAR', 'EOLICA', 'GAS_NATURAL']
cores = {'BASE': 'blue', 'RENOVAVEIS_ACELERADAS': 'green', 
         'FOSSIL_RESISTENTE': 'red', 'NUCLEAR_PLUS': 'purple'}

for i, fonte in enumerate(fontes_viz):
    if i < len(axes):
        
        # Plotar cada cen√°rio
        for nome_cenario, df_resultado in resultados_finais.items():
            if fonte in df_resultado.columns:
                cor = cores.get(nome_cenario, 'gray')
                axes[i].plot(df_resultado['ANO'], df_resultado[fonte], 
                           label=nome_cenario, color=cor, linewidth=3, 
                           marker='o', markersize=4, alpha=0.8)
        
        # Linha de refer√™ncia (2023)
        if fonte in tendencias:
            valor_atual = tendencias[fonte]['valor_2023']
            axes[i].axhline(y=valor_atual, color='black', linestyle='--', 
                           alpha=0.5, label=f'Atual: {valor_atual:.1f}%')
        
        axes[i].set_title(f'{fonte} - Differentiated Scenarios', fontweight='bold', fontsize=12)
        axes[i].set_xlabel('Year')
        axes[i].set_ylabel('Share (%)')
        axes[i].legend(fontsize=9)
        axes[i].grid(True, alpha=0.3)
        axes[i].set_xlim(2023, 2050)
        axes[i].set_ylim(0, max(100, axes[i].get_ylim()[1]))

plt.tight_layout()
# plt.suptitle('Final hybrid model - Matriz El√©trica Brasileira\nTend√™ncias Hist√≥ricas + Pol√≠ticas + Restri√ß√µes Real√≠sticas', fontsize=14, fontweight='bold', y=1.02)
plt.suptitle('Final hybrid model - Brazilian grid\nHistorical Trends + Policies + Realistic Constraints', 
             fontsize=14, fontweight='bold', y=1.02)
plt.savefig('modelo_hibrido_EN.png', dpi=300, bbox_inches='tight')
plt.show()

# === 11. RESUMO EXECUTIVO ===
print("\n" + "="*65)
print("MODELO H√çBRIDO COMPLETO - RESUMO EXECUTIVO")
print("="*65)

print(f"\nCARACTER√çSTICAS DO MODELO:")
print(f"   ‚Ä¢ Tend√™ncias hist√≥ricas: 2014-2023 (p√≥s-crise h√≠drica)")
print(f"   ‚Ä¢ Transi√ß√µes S-curve real√≠sticas")
print(f"   ‚Ä¢ 5 features avan√ßadas (sinergias, competi√ß√£o)")
print(f"   ‚Ä¢ 4 cen√°rios diferenciados")
print(f"   ‚Ä¢ Restri√ß√µes por fonte energ√©tica")

print(f"\nRESULTADOS BASE (2050):")
base_2050 = dados_2050.get('BASE', {})
if base_2050 is not None and len(base_2050) > 0:
    principais_base = base_2050.nlargest(3)
    for fonte, valor in principais_base.items():
        print(f"   ‚Ä¢ {fonte}: {valor:.1f}%")

print(f"\nDIFERENCIA√á√ÉO DOS CEN√ÅRIOS (range em 2050):")
if len(dados_2050) > 1:
    for fonte in ['SOLAR', 'HIDRAULICA', 'EOLICA']:
        if fonte in df_comp_2050.index:
            valores_fonte = df_comp_2050.loc[fonte]
            min_val, max_val = valores_fonte.min(), valores_fonte.max()
            print(f"   ‚Ä¢ {fonte}: {min_val:.1f}% - {max_val:.1f}% (Œî{max_val-min_val:.1f}%)")

print(f"\nPR√ìXIMAS VALIDA√á√ïES RECOMENDADAS:")
print(f"   1. Comparar com proje√ß√µes EPE PNE 2050")
print(f"   2. Incluir custos levelizados de energia (LCOE)")
print(f"   3. Considerar limita√ß√µes de transmiss√£o")
print(f"   4. An√°lise de sensibilidade clim√°tica")

print(f"\nMODELO PRONTO PARA USO OPERACIONAL!")
print("="*65)

import pandas as pd
import numpy as np
import warnings

# Carregamento dos dados (assumindo que j√° foram lidos pelo c√≥digo anterior)
# df_matriz = pd.read_csv("base_matriz_eletrica_normalizada.csv")
# resultados_finais = {
#     "BASE": df_projecao_base,
#     "RENOVAVEIS_ACELERADAS": df_projecao_renov,
#     ...
# }

print("\nCONCATENANDO DADOS HIST√ìRICOS (2015-2023) COM PROJE√á√ïES...")

# Filtrar dados hist√≥ricos de 2015 a 2023
historico = df_matriz[(df_matriz['ANO'] >= 2015) & (df_matriz['ANO'] <= 2023)].copy()
# Garantir que as colunas s√£o as mesmas, s√≥ para confer√™ncia
fontes_cols = [col for col in historico.columns if col != 'ANO']
historico = historico[['ANO'] + fontes_cols]

resultados_completos = {}
for nome_cenario, df_projetado in resultados_finais.items():
    # Concatena o hist√≥rico e a proje√ß√£o
    df_completo = pd.concat([historico, df_projetado], ignore_index=True)
    df_completo = df_completo.sort_values(by='ANO').reset_index(drop=True)
    resultados_completos[nome_cenario] = df_completo

# Exibir os primeiros e √∫ltimos anos para verifica√ß√£o
print("\nDados consolidados (primeiras linhas):")
print(resultados_completos['BASE'].head())
print("\nDados consolidados (√∫ltimas linhas):")
print(resultados_completos['BASE'].tail())

print("\nDataFrame completo para todos os cen√°rios, de 2015 at√© 2065, criado com sucesso.")

# Criar um DataFrame √∫nico com todos os cen√°rios
df_completo_final = pd.DataFrame()
for cenario, df in resultados_completos.items():
    df['CENARIO'] = cenario
    df_completo_final = pd.concat([df_completo_final, df], ignore_index=True)
    
df_completo_final.to_csv("matriz_eletrica_completa_2015-2065.csv", index=False)
print("\nMatriz el√©trica completa (2015-2065) salva em: 'matriz_eletrica_completa_2015-2065.csv'")
